# Using Jarvis App-to-App Authentication

This guide shows how your service (a “Jarvis app”) should authenticate to `jarvis-auth` and other Jarvis services using the new app-to-app scheme.

## What you get
- A unique `app_id` (e.g., `llm-proxy`, `recipes-api`).
- A long, random `app_key` (secret). You store it; we only keep a hash.
- Simple header-based auth on every call you make to `jarvis-auth` (and any Jarvis endpoints that require app auth).

## Admin bootstrapping (one-time per app)
1) An admin calls `POST /admin/app-clients` on `jarvis-auth` with:
```json
{ "app_id": "your-app-id", "name": "Your Service Name" }
```
2) The response contains your **raw `key` once**. Save it in your secrets manager (env var, vault, etc.). We cannot recover it later.

## Headers to send on every protected request
Add these HTTP headers:
```
X-Jarvis-App-Id: your-app-id
X-Jarvis-App-Key: <your raw key>
```
If either is missing/invalid or the app is revoked, you get `401 {"detail": "Missing app credentials"}` or `{"detail": "Invalid app credentials"}`.

## Environment variables (recommended)
It is recommended to store your `app_id` and `app_key` as environment variables in your service deployment environment (e.g., `JARVIS_AUTH_APP_ID`, `JARVIS_AUTH_APP_KEY`). This keeps secrets out of code and configuration files, and makes rotation and deployment safer and easier. Your HTTP client should read these variables at startup and include them in the headers on every request.

## Typical usage
- Outbound calls from your service to `jarvis-auth` (e.g., token validation, internal endpoints) must include the two headers above.
- If another Jarvis service requires app auth, use the same headers.

## App auth vs user auth
App-to-app authentication is separate from user authentication. App auth identifies the calling service, not an end user. Use app auth headers only for service-to-service calls that require trusted app identity. For user-level authorization, continue to use user tokens or other user auth mechanisms.

## Environments (dev/stage/prod)
Use distinct `app_id` and `app_key` pairs for different environments to avoid cross-environment leaks or mistakes. For example, `my-service-dev` vs `my-service-prod`. The admin API supports managing multiple app clients for this purpose.

## Logging & debugging
Never log the raw `app_key` or include it in error messages. Log only the `app_id` and request metadata for debugging. If you see 401 errors, verify that the correct `app_id` and `app_key` are configured and being sent in headers.

## Key rotation
If you need to rotate:
1) Admin calls `POST /admin/app-clients/{app_id}/rotate`.
2) A new `key` is returned once. Update your deployment secrets and roll out.
Old key stops working immediately.

## Revocation
- Admin can revoke with `POST /admin/app-clients/{app_id}/revoke`.
- After revocation, all requests with that app’s key receive 401.

## Listing (metadata only)
- Admin can `GET /admin/app-clients` to see active/inactive apps and timestamps (no keys).

## Security notes
- Transport: use TLS for all service-to-service calls.
- Storage: keep `app_key` only in secure config (env/secret manager); never log it.
- Length/entropy: keys are high-entropy (generated by `jarvis-auth`); do not truncate.

## Minimal client example (pseudo-code)
```python
import requests

APP_ID = "your-app-id"
APP_KEY = "your-raw-key"  # from admin create/rotate, stored in secrets

def call_auth_internal():
    resp = requests.get(
        "https://jarvis-auth.internal/internal/app-ping",
        headers={
            "X-Jarvis-App-Id": APP_ID,
            "X-Jarvis-App-Key": APP_KEY,
        },
        timeout=5,
    )
    resp.raise_for_status()
    return resp.json()
```

## Failure modes to expect
- Missing headers → 401 “Missing app credentials”
- Bad/old key or revoked app → 401 “Invalid app credentials”
- Inactive service during rotation → retry with new key after rollout

## Handling 401s in clients
When receiving a 401 response, clients should:
- Check if the `X-Jarvis-App-Id` and `X-Jarvis-App-Key` headers are correctly set.
- Verify that the keys have not been revoked or rotated; if rotated, update to the new key.
- Implement retry logic after secret updates during key rotation to avoid downtime.
- Alert on unexpected 401s to catch configuration or credential issues early.

## Checklist for onboarding a new app
- [ ] Get `app_id` and `key` from admin (`POST /admin/app-clients`).
- [ ] Store `app_key` securely; never commit to repo or logs.
- [ ] Configure your HTTP client to send `X-Jarvis-App-Id` and `X-Jarvis-App-Key`.
- [ ] Add runbook for rotation using `/admin/app-clients/{app_id}/rotate`.
- [ ] Add alerting for unexpected 401s on internal calls.


## Common Questions / Implementation Notes

### 1) Where should the app_id/app_key be validated?
Validation is always performed **server-side inside jarvis-auth**, using the `require_app_client` dependency. Client services (such as llm-proxy) do **not** maintain a local allowlist and should never validate keys themselves. All they do is send:
```
X-Jarvis-App-Id
X-Jarvis-App-Key
```
jarvis-auth verifies:
- The app exists,
- The app is active,
- The key matches the stored hash.

### 2) Is there a dedicated endpoint to verify app credentials?
No. Verification happens implicitly on any jarvis-auth endpoint that requires app authentication. The mechanism is request-based, not an explicit "verify-app" call.

If you need a simple connectivity test, jarvis-auth will expose a lightweight internal endpoint:
```
GET /internal/app-ping
```
Clients send the two headers and receive:
```
{ "status": "ok", "app_id": "<your-app-id>" }
```
This endpoint also uses the same app-auth dependency.

### 3) Should clients cache validations?
No caching is required. App-to-app auth is extremely cheap (single hash comparison). Clients should **send headers on every request** and let jarvis-auth validate each time.

Caching may be introduced later if we add complex per-app authorization, but for now it provides no benefit and adds rotation complexity.

### 4) Are health endpoints authenticated?
All **public health endpoints remain unauthenticated**, such as:
```
GET /health
```
Internal operational endpoints (like `/internal/app-ping`) **are authenticated**, because they confirm identity of the calling service.

---

## Securing Your Service’s Inbound API Using Jarvis App-to-App Authentication

### Why inbound app auth
- Prevent other services (or stray callers) from invoking your internal APIs (e.g., `llm-proxy /chat`, `recipes-api /completions`, `command-center /internal/*`) without proving they are a trusted Jarvis app.
- Keep user auth separate from app auth: user tokens prove end users, app keys prove calling services.

### Inbound validation rule set (centralized in jarvis-auth)
- Require callers to send:
  - `X-Jarvis-App-Id`
  - `X-Jarvis-App-Key`
- Your service should **forward these headers to jarvis-auth** for validation (do not maintain a local allowlist or hash keys locally).
- Use the existing validation endpoint in jarvis-auth:
  - `GET /internal/app-ping`
  - Headers: `X-Jarvis-App-Id`, `X-Jarvis-App-Key`
  - Success: `200 {"app_id": "<id>", "name": "<name>"}`; Failure: `401 {"detail": "Missing app credentials"}` or `{"detail": "Invalid app credentials"}`
- Health endpoints in your service remain unauthenticated unless you explicitly change them.

### Environment variable pattern (recommended)
- Store your own `app_id` / `app_key` to call jarvis-auth (outbound) as documented above.
- For inbound validation, **do not store other apps’ keys**. Simply forward the headers you receive to jarvis-auth for verification.

### FastAPI-style dependency/middleware (conceptual)
- Create a reusable dependency (e.g., `require_inbound_app_auth`) that:
  - Reads the two headers.
  - Calls jarvis-auth `/internal/app-ping` with those headers.
  - On 200, sets `request.state.calling_app_id` to the returned `app_id`.
  - On 401, rejects with a matching 401 in your service.
- Apply this dependency to all protected routes; leave health probes public.

### Which endpoints to protect vs public
- Protect: `/chat`, `/completions`, `/internal/*`, and any operational or mutation endpoints.
- Public: `/health` (and optionally `/metrics` if you want it open; otherwise protect it too).

### Rotation flow (inbound keys)
- Keys rotate in jarvis-auth via `POST /admin/app-clients/{app_id}/rotate` (returns a new key once).
- Caller services update to the new key and send it in headers.
- Your service does not need to update any local allowlist—jarvis-auth is the source of truth.

### Failure modes & debugging
- 401 Missing: caller did not send headers.
- 401 Invalid: wrong/old key, revoked/inactive app, or jarvis-auth rejects.
- Rotation race: caller still on old key; they must update to the new key.
- Logging: never log raw keys; log only `app_id` and request metadata. Alert on unexpected 401 spikes.

## Checklist for onboarding a new app
